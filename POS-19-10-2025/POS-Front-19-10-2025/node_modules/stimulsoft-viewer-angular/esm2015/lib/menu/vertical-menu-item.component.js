import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter } from '@angular/core';
import { ModelService } from '../services/model.service';
import { MenuService } from './menu.service';
let VerticalMenuItemComponent = class VerticalMenuItemComponent {
    constructor(model, menuService) {
        this.model = model;
        this.menuService = menuService;
        this.styleName = 'stiJsViewerMenuStandartItem';
        this.action = new EventEmitter();
        this.over = false;
        this._enabled = true;
    }
    ngOnInit() { }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        if (!value) {
            this.over = false;
        }
        this._enabled = value;
    }
    get className() {
        var _a;
        return this.styleName ? this.styleName + ' ' + (this.enabled ? (this.styleName + (this.over ? 'Over' : (((_a = this.item) === null || _a === void 0 ? void 0 : _a.selected) ? 'Selected' : 'Default'))) : this.styleName + 'Disabled') : '';
    }
    mouseover() {
        if (!this.enabled) {
            return;
        }
        this.over = true;
    }
    mouseout() {
        if (!this.enabled) {
            return;
        }
        this.over = false;
    }
    click() {
        if (this._enabled) {
            this.action.emit(this.item);
        }
    }
    get isSmallItem() {
        return this.styleName && this.styleName.indexOf('MenuStandartItem') >= 0;
    }
};
VerticalMenuItemComponent.ctorParameters = () => [
    { type: ModelService },
    { type: MenuService }
];
__decorate([
    Input()
], VerticalMenuItemComponent.prototype, "styleName", void 0);
__decorate([
    Input()
], VerticalMenuItemComponent.prototype, "item", void 0);
__decorate([
    Input()
], VerticalMenuItemComponent.prototype, "imageSizesWidth", void 0);
__decorate([
    Input()
], VerticalMenuItemComponent.prototype, "imageSizesHeight", void 0);
__decorate([
    Output()
], VerticalMenuItemComponent.prototype, "action", void 0);
__decorate([
    Input()
], VerticalMenuItemComponent.prototype, "enabled", null);
VerticalMenuItemComponent = __decorate([
    Component({
        selector: 'sti-vertical-menu-item',
        template: `
    <div [style.height]="item?.type == 'DigitalSignature' ? 'auto' :(model.options.isMobileDevice ? '0.4in' : (model.options.isTouchDevice ? '30px' : '24px'))"
         [class]="className"
         [style.width]="item?.type == 'DigitalSignature' ? '100%' :  menuService.getVerticalMenu().width + 'px'"
         [style.lineHeight]="item?.type == 'DigitalSignature' ? 1.3 : null"
         (mouseover)="mouseover()"
         (mouseout)="mouseout()"
         (click)="click()">
         <table class="stiJsViewerClearAllStyles" cellpadding="0" cellspacing="0" style="height: 100%; width: 100%">
            <tbody>
              <tr class="stiJsViewerClearAllStyles">
                 <td *ngIf="item?.imageName != null && !model.options.appearance.rightToLeft"
                     style="width:22px; min-width = 22px; padding: 0; textAlign: center; lineHeight: 0"
                     class="stiJsViewerClearAllStyles">
                     <img [style.width.px]="(imageSizesWidth ? imageSizesWidth : (isSmallItem ? 16 : 32))"
                          [style.height.px]="(imageSizesHeight ? imageSizesHeight : (isSmallItem ? 16 : 32))"
                          [src]="model.img(item?.imageName)"
                          [style.visible]="model.img(item?.imageName) === '' ? 'none' : ''" />
                </td>

                <td *ngIf="item?.caption != null && !model.options.appearance.rightToLeft && item?.type != 'DigitalSignature'"
                     style="padding: 0px 20px 0px 7px; text-align: left; white-space: nowrap;"
                     [style.fontSize]="model.options.isMobileDevice ? '0.16in' : ''"
                     class="stiJsViewerClearAllStyles">
                     {{item?.caption}}
                </td>

                <td *ngIf="item?.caption != null && !model.options.appearance.rightToLeft && item?.type == 'DigitalSignature'"
                     style="padding: 8px 20px 8px 8px ; text-align: left; white-space: nowrap;"
                     [style.fontSize]="model.options.isMobileDevice ? '0.16in' : ''"
                     class="stiJsViewerClearAllStyles" [innerHtml]="item?.caption">
                </td>

                <!-- right-to-left -->
                <td *ngIf="item?.caption != null && model.options.appearance.rightToLeft && item?.type == 'DigitalSignature'"
                     style="padding: 8px 20px 8px 8px; text-align: right; white-space: nowrap;"
                     [style.fontSize]="model.options.isMobileDevice ? '0.16in' : ''"
                     class="stiJsViewerClearAllStyles" [innerHtml]="item?.caption">
                </td>

                <td *ngIf="item?.caption != null && model.options.appearance.rightToLeft && item?.type != 'DigitalSignature'"
                     style="padding: 0 7px 0 20px; text-align: right; white-space: nowrap;"
                     [style.fontSize]="model.options.isMobileDevice ? '0.16in' : ''"
                     class="stiJsViewerClearAllStyles">
                     {{item?.caption}}
                </td>

                <td *ngIf="item?.imageName != null && model.options.appearance.rightToLeft"
                     style="width:22px; min-width = 22px; padding: 0; textAlign: center; lineHeight: 0"
                     class="stiJsViewerClearAllStyles">
                     <img [style.width.px]="(imageSizesWidth ? imageSizesWidth : (isSmallItem ? 16 : 32))"
                          [style.height.px]="(imageSizesHeight ? imageSizesHeight : (isSmallItem ? 16 : 32))"
                          [src]="model.img(item?.imageName)"
                          [style.visible]="model.img(item?.imageName) === '' ? 'none' : ''" />
                </td>
              </tr>
            </tbody>
          </table>
    </div>
  `
    })
], VerticalMenuItemComponent);
export { VerticalMenuItemComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVydGljYWwtbWVudS1pdGVtLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3N0aW11bHNvZnQtdmlld2VyLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvbWVudS92ZXJ0aWNhbC1tZW51LWl0ZW0uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFVLEtBQUssRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQy9FLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUV6RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFrRTdDLElBQWEseUJBQXlCLEdBQXRDLE1BQWEseUJBQXlCO0lBWXBDLFlBQW1CLEtBQW1CLEVBQVMsV0FBd0I7UUFBcEQsVUFBSyxHQUFMLEtBQUssQ0FBYztRQUFTLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBVjlELGNBQVMsR0FBRyw2QkFBNkIsQ0FBQztRQUt6QyxXQUFNLEdBQXNCLElBQUksWUFBWSxFQUFFLENBQUM7UUFFekQsU0FBSSxHQUFHLEtBQUssQ0FBQztRQUNMLGFBQVEsR0FBRyxJQUFJLENBQUM7SUFFbUQsQ0FBQztJQUU1RSxRQUFRLEtBQUssQ0FBQztJQUVMLElBQUksT0FBTztRQUNsQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdkIsQ0FBQztJQUVELElBQUksT0FBTyxDQUFDLEtBQWM7UUFDeEIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNWLElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO1NBQ25CO1FBQ0QsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7SUFDeEIsQ0FBQztJQUVELElBQUksU0FBUzs7UUFDWCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsUUFBUSxFQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzlMLENBQUM7SUFFRCxTQUFTO1FBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDakIsT0FBTztTQUNSO1FBQ0QsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7SUFDbkIsQ0FBQztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNqQixPQUFPO1NBQ1I7UUFDRCxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBRUQsS0FBSztRQUNILElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDN0I7SUFDSCxDQUFDO0lBRUQsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNFLENBQUM7Q0FDRixDQUFBOztZQTFDMkIsWUFBWTtZQUFzQixXQUFXOztBQVY5RDtJQUFSLEtBQUssRUFBRTs0REFBMkM7QUFDMUM7SUFBUixLQUFLLEVBQUU7dURBQVk7QUFDWDtJQUFSLEtBQUssRUFBRTtrRUFBeUI7QUFDeEI7SUFBUixLQUFLLEVBQUU7bUVBQTBCO0FBRXhCO0lBQVQsTUFBTSxFQUFFO3lEQUFnRDtBQVNoRDtJQUFSLEtBQUssRUFBRTt3REFFUDtBQWxCVSx5QkFBeUI7SUFoRXJDLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSx3QkFBd0I7UUFDbEMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJEVDtLQUNGLENBQUM7R0FFVyx5QkFBeUIsQ0FzRHJDO1NBdERZLHlCQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTW9kZWxTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbW9kZWwuc2VydmljZSc7XHJcbmltcG9ydCB7IEl0ZW0gfSBmcm9tICcuLi9zZXJ2aWNlcy9vYmplY3RzJztcclxuaW1wb3J0IHsgTWVudVNlcnZpY2UgfSBmcm9tICcuL21lbnUuc2VydmljZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3N0aS12ZXJ0aWNhbC1tZW51LWl0ZW0nLFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8ZGl2IFtzdHlsZS5oZWlnaHRdPVwiaXRlbT8udHlwZSA9PSAnRGlnaXRhbFNpZ25hdHVyZScgPyAnYXV0bycgOihtb2RlbC5vcHRpb25zLmlzTW9iaWxlRGV2aWNlID8gJzAuNGluJyA6IChtb2RlbC5vcHRpb25zLmlzVG91Y2hEZXZpY2UgPyAnMzBweCcgOiAnMjRweCcpKVwiXHJcbiAgICAgICAgIFtjbGFzc109XCJjbGFzc05hbWVcIlxyXG4gICAgICAgICBbc3R5bGUud2lkdGhdPVwiaXRlbT8udHlwZSA9PSAnRGlnaXRhbFNpZ25hdHVyZScgPyAnMTAwJScgOiAgbWVudVNlcnZpY2UuZ2V0VmVydGljYWxNZW51KCkud2lkdGggKyAncHgnXCJcclxuICAgICAgICAgW3N0eWxlLmxpbmVIZWlnaHRdPVwiaXRlbT8udHlwZSA9PSAnRGlnaXRhbFNpZ25hdHVyZScgPyAxLjMgOiBudWxsXCJcclxuICAgICAgICAgKG1vdXNlb3Zlcik9XCJtb3VzZW92ZXIoKVwiXHJcbiAgICAgICAgIChtb3VzZW91dCk9XCJtb3VzZW91dCgpXCJcclxuICAgICAgICAgKGNsaWNrKT1cImNsaWNrKClcIj5cclxuICAgICAgICAgPHRhYmxlIGNsYXNzPVwic3RpSnNWaWV3ZXJDbGVhckFsbFN0eWxlc1wiIGNlbGxwYWRkaW5nPVwiMFwiIGNlbGxzcGFjaW5nPVwiMFwiIHN0eWxlPVwiaGVpZ2h0OiAxMDAlOyB3aWR0aDogMTAwJVwiPlxyXG4gICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgPHRyIGNsYXNzPVwic3RpSnNWaWV3ZXJDbGVhckFsbFN0eWxlc1wiPlxyXG4gICAgICAgICAgICAgICAgIDx0ZCAqbmdJZj1cIml0ZW0/LmltYWdlTmFtZSAhPSBudWxsICYmICFtb2RlbC5vcHRpb25zLmFwcGVhcmFuY2UucmlnaHRUb0xlZnRcIlxyXG4gICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIndpZHRoOjIycHg7IG1pbi13aWR0aCA9IDIycHg7IHBhZGRpbmc6IDA7IHRleHRBbGlnbjogY2VudGVyOyBsaW5lSGVpZ2h0OiAwXCJcclxuICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJzdGlKc1ZpZXdlckNsZWFyQWxsU3R5bGVzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgIDxpbWcgW3N0eWxlLndpZHRoLnB4XT1cIihpbWFnZVNpemVzV2lkdGggPyBpbWFnZVNpemVzV2lkdGggOiAoaXNTbWFsbEl0ZW0gPyAxNiA6IDMyKSlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPVwiKGltYWdlU2l6ZXNIZWlnaHQgPyBpbWFnZVNpemVzSGVpZ2h0IDogKGlzU21hbGxJdGVtID8gMTYgOiAzMikpXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBbc3JjXT1cIm1vZGVsLmltZyhpdGVtPy5pbWFnZU5hbWUpXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUudmlzaWJsZV09XCJtb2RlbC5pbWcoaXRlbT8uaW1hZ2VOYW1lKSA9PT0gJycgPyAnbm9uZScgOiAnJ1wiIC8+XHJcbiAgICAgICAgICAgICAgICA8L3RkPlxyXG5cclxuICAgICAgICAgICAgICAgIDx0ZCAqbmdJZj1cIml0ZW0/LmNhcHRpb24gIT0gbnVsbCAmJiAhbW9kZWwub3B0aW9ucy5hcHBlYXJhbmNlLnJpZ2h0VG9MZWZ0ICYmIGl0ZW0/LnR5cGUgIT0gJ0RpZ2l0YWxTaWduYXR1cmUnXCJcclxuICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJwYWRkaW5nOiAwcHggMjBweCAwcHggN3B4OyB0ZXh0LWFsaWduOiBsZWZ0OyB3aGl0ZS1zcGFjZTogbm93cmFwO1wiXHJcbiAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5mb250U2l6ZV09XCJtb2RlbC5vcHRpb25zLmlzTW9iaWxlRGV2aWNlID8gJzAuMTZpbicgOiAnJ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwic3RpSnNWaWV3ZXJDbGVhckFsbFN0eWxlc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICB7e2l0ZW0/LmNhcHRpb259fVxyXG4gICAgICAgICAgICAgICAgPC90ZD5cclxuXHJcbiAgICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJpdGVtPy5jYXB0aW9uICE9IG51bGwgJiYgIW1vZGVsLm9wdGlvbnMuYXBwZWFyYW5jZS5yaWdodFRvTGVmdCAmJiBpdGVtPy50eXBlID09ICdEaWdpdGFsU2lnbmF0dXJlJ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwicGFkZGluZzogOHB4IDIwcHggOHB4IDhweCA7IHRleHQtYWxpZ246IGxlZnQ7IHdoaXRlLXNwYWNlOiBub3dyYXA7XCJcclxuICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmZvbnRTaXplXT1cIm1vZGVsLm9wdGlvbnMuaXNNb2JpbGVEZXZpY2UgPyAnMC4xNmluJyA6ICcnXCJcclxuICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJzdGlKc1ZpZXdlckNsZWFyQWxsU3R5bGVzXCIgW2lubmVySHRtbF09XCJpdGVtPy5jYXB0aW9uXCI+XHJcbiAgICAgICAgICAgICAgICA8L3RkPlxyXG5cclxuICAgICAgICAgICAgICAgIDwhLS0gcmlnaHQtdG8tbGVmdCAtLT5cclxuICAgICAgICAgICAgICAgIDx0ZCAqbmdJZj1cIml0ZW0/LmNhcHRpb24gIT0gbnVsbCAmJiBtb2RlbC5vcHRpb25zLmFwcGVhcmFuY2UucmlnaHRUb0xlZnQgJiYgaXRlbT8udHlwZSA9PSAnRGlnaXRhbFNpZ25hdHVyZSdcIlxyXG4gICAgICAgICAgICAgICAgICAgICBzdHlsZT1cInBhZGRpbmc6IDhweCAyMHB4IDhweCA4cHg7IHRleHQtYWxpZ246IHJpZ2h0OyB3aGl0ZS1zcGFjZTogbm93cmFwO1wiXHJcbiAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5mb250U2l6ZV09XCJtb2RlbC5vcHRpb25zLmlzTW9iaWxlRGV2aWNlID8gJzAuMTZpbicgOiAnJ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwic3RpSnNWaWV3ZXJDbGVhckFsbFN0eWxlc1wiIFtpbm5lckh0bWxdPVwiaXRlbT8uY2FwdGlvblwiPlxyXG4gICAgICAgICAgICAgICAgPC90ZD5cclxuXHJcbiAgICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJpdGVtPy5jYXB0aW9uICE9IG51bGwgJiYgbW9kZWwub3B0aW9ucy5hcHBlYXJhbmNlLnJpZ2h0VG9MZWZ0ICYmIGl0ZW0/LnR5cGUgIT0gJ0RpZ2l0YWxTaWduYXR1cmUnXCJcclxuICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJwYWRkaW5nOiAwIDdweCAwIDIwcHg7IHRleHQtYWxpZ246IHJpZ2h0OyB3aGl0ZS1zcGFjZTogbm93cmFwO1wiXHJcbiAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5mb250U2l6ZV09XCJtb2RlbC5vcHRpb25zLmlzTW9iaWxlRGV2aWNlID8gJzAuMTZpbicgOiAnJ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwic3RpSnNWaWV3ZXJDbGVhckFsbFN0eWxlc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICB7e2l0ZW0/LmNhcHRpb259fVxyXG4gICAgICAgICAgICAgICAgPC90ZD5cclxuXHJcbiAgICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJpdGVtPy5pbWFnZU5hbWUgIT0gbnVsbCAmJiBtb2RlbC5vcHRpb25zLmFwcGVhcmFuY2UucmlnaHRUb0xlZnRcIlxyXG4gICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIndpZHRoOjIycHg7IG1pbi13aWR0aCA9IDIycHg7IHBhZGRpbmc6IDA7IHRleHRBbGlnbjogY2VudGVyOyBsaW5lSGVpZ2h0OiAwXCJcclxuICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJzdGlKc1ZpZXdlckNsZWFyQWxsU3R5bGVzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgIDxpbWcgW3N0eWxlLndpZHRoLnB4XT1cIihpbWFnZVNpemVzV2lkdGggPyBpbWFnZVNpemVzV2lkdGggOiAoaXNTbWFsbEl0ZW0gPyAxNiA6IDMyKSlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPVwiKGltYWdlU2l6ZXNIZWlnaHQgPyBpbWFnZVNpemVzSGVpZ2h0IDogKGlzU21hbGxJdGVtID8gMTYgOiAzMikpXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBbc3JjXT1cIm1vZGVsLmltZyhpdGVtPy5pbWFnZU5hbWUpXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUudmlzaWJsZV09XCJtb2RlbC5pbWcoaXRlbT8uaW1hZ2VOYW1lKSA9PT0gJycgPyAnbm9uZScgOiAnJ1wiIC8+XHJcbiAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgPC9kaXY+XHJcbiAgYFxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIFZlcnRpY2FsTWVudUl0ZW1Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xyXG5cclxuICBASW5wdXQoKSBzdHlsZU5hbWUgPSAnc3RpSnNWaWV3ZXJNZW51U3RhbmRhcnRJdGVtJztcclxuICBASW5wdXQoKSBpdGVtOiBJdGVtO1xyXG4gIEBJbnB1dCgpIGltYWdlU2l6ZXNXaWR0aDogbnVtYmVyO1xyXG4gIEBJbnB1dCgpIGltYWdlU2l6ZXNIZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgQE91dHB1dCgpIGFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gIG92ZXIgPSBmYWxzZTtcclxuICBwcml2YXRlIF9lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgY29uc3RydWN0b3IocHVibGljIG1vZGVsOiBNb2RlbFNlcnZpY2UsIHB1YmxpYyBtZW51U2VydmljZTogTWVudVNlcnZpY2UpIHsgfVxyXG5cclxuICBuZ09uSW5pdCgpIHsgfVxyXG5cclxuICBASW5wdXQoKSBnZXQgZW5hYmxlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xyXG4gIH1cclxuXHJcbiAgc2V0IGVuYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcclxuICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgdGhpcy5vdmVyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9lbmFibGVkID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBnZXQgY2xhc3NOYW1lKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHlsZU5hbWUgPyB0aGlzLnN0eWxlTmFtZSArICcgJyArICh0aGlzLmVuYWJsZWQgPyAodGhpcy5zdHlsZU5hbWUgKyAodGhpcy5vdmVyID8gJ092ZXInIDogKHRoaXMuaXRlbT8uc2VsZWN0ZWQgPyAnU2VsZWN0ZWQnIDogJ0RlZmF1bHQnKSkpIDogdGhpcy5zdHlsZU5hbWUgKyAnRGlzYWJsZWQnKSA6ICcnO1xyXG4gIH1cclxuXHJcbiAgbW91c2VvdmVyKCkge1xyXG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5vdmVyID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIG1vdXNlb3V0KCkge1xyXG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5vdmVyID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBjbGljaygpIHtcclxuICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XHJcbiAgICAgIHRoaXMuYWN0aW9uLmVtaXQodGhpcy5pdGVtKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBpc1NtYWxsSXRlbSgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnN0eWxlTmFtZSAmJiB0aGlzLnN0eWxlTmFtZS5pbmRleE9mKCdNZW51U3RhbmRhcnRJdGVtJykgPj0gMDtcclxuICB9XHJcbn1cclxuIl19