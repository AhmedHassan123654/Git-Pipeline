import { __decorate } from "tslib";
import { Component, Input, EventEmitter, Output, ViewChild } from '@angular/core';
import { ModelService } from '../services/model.service';
import { HelperService } from '../services/helper.service';
import { trigger, state, transition, style, animate } from '@angular/animations';
import { FormService } from './form.service';
let BaseFormComponent = class BaseFormComponent {
    constructor(model, helper, formService) {
        this.model = model;
        this.helper = helper;
        this.formService = formService;
        this.changeVisibility = new EventEmitter();
        this.action = new EventEmitter();
        this.level = 1;
        this.showCancel = true;
        this.showButtons = true;
        this.showSeparator = true;
        this.display = 'none';
    }
    ngOnInit() { }
    startAnimation(event) {
        if (event.toState === 'visible') {
            this.display = '';
            if (this.defaultTop != null) {
                this.formService.centerForm(this, this.defaultTop);
            }
        }
    }
    doneAnimation(event) {
        if (event.toState === 'hidden') {
            this.display = 'none';
        }
        this.changeVisibility.emit(event.toState);
    }
};
BaseFormComponent.ctorParameters = () => [
    { type: ModelService },
    { type: HelperService },
    { type: FormService }
];
__decorate([
    ViewChild('element')
], BaseFormComponent.prototype, "element", void 0);
__decorate([
    Output()
], BaseFormComponent.prototype, "changeVisibility", void 0);
__decorate([
    Output()
], BaseFormComponent.prototype, "action", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "level", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "caption", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "helpUrl", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "fontFamily", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "color", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "fontSize", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "containerPadding", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "name", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "defaultTop", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "showCancel", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "showButtons", void 0);
__decorate([
    Input()
], BaseFormComponent.prototype, "showSeparator", void 0);
BaseFormComponent = __decorate([
    Component({
        selector: 'sti-base-form',
        template: `
    <div #element class="stiJsViewerForm"
      [style.zIndex]="level * 10 + 1"
      [@.disabled]="!model.options.toolbar.menuAnimation"
      [style.fontFamily]="fontFamily"
      [style.color]="color"
      [style.fontSize]="fontSize"
      [style.left.px]="formService.form?.left"
      [style.top.px]="formService.form?.top"
      [style.display]="display"
      [@showForm]="formService.form?.name == name ? 'visible' : 'hidden'"
      (@showForm.start)="startAnimation($event)"
      (@showForm.done)="doneAnimation($event)">
      <div class="stiJsViewerFormHeader"
        (mousedown)="formService.startMove(name, $event)"
        (touchstart)="formService.startMove(name, null, $event)"
        (touchmove)="formService.move($event)"
        (touchend)="formService.stopMove()">
        <table class="stiJsViewerClearAllStyles" cellpadding="0" cellspacing="0" style="width: 100%;">
          <tbody>
            <tr class="stiJsViewerClearAllStyles">
              <td class="stiJsViewerClearAllStyles" style="text-align: left; padding: 5px 10px 8px 15px;">
                {{caption}}
              </td>
              <td *ngIf="helpUrl != null && model.options.appearance.showDialogsHelp" class="stiJsViewerClearAllStyles" style="width: 20px; text-align: right; padding: 2px 0px 1px 0px; vertical-align: top;">
                <sti-button [imageMargin]="'0 2px 0 2px'" [display]="'inline-block'" (action)="helper.showHelpWindow(helpUrl)">
                </sti-button>
              </td>
              <td class="stiJsViewerClearAllStyles" style="vertical-align: top; width: 30px; text-align: right; padding: 2px 1px 1px;">
                <sti-button [imageMargin]="'0 2px 0 2px'" [display]="'inline-block'" [imageName]="'CloseForm.png'" (action)="formService.closeForm(name)">
                </sti-button>
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="stiJsViewerFormContainer" [style.padding]="containerPadding">
        <ng-content>
        </ng-content>
      </div>

      <div *ngIf="showSeparator" class="stiJsViewerFormSeparator"></div>

      <div *ngIf="showButtons" class="stiJsViewerFormButtonsPanel">
        <table class="stiJsViewerClearAllStyles" cellpadding="0" cellspacing="0">
          <tbody>
            <tr class="stiJsViewerClearAllStyles">
              <td class="stiJsViewerClearAllStyles" style="padding: 8px;">
                <sti-form-button [caption]="model.loc('ButtonOk')" (action)="action.emit()">
                </sti-form-button>
              </td>
              <td *ngIf="showCancel" class="stiJsViewerClearAllStyles" style="padding: 8px 8px 8px 0px;">
                <sti-form-button [caption]="model.loc('ButtonCancel')" (action)="formService.closeForm(name)">
                </sti-form-button>
              </td>
            </tr>
          </tbody>
        </table>
      </div>

    </div>
  `,
        animations: [
            trigger('showForm', [
                state('hidden', style({ opacity: '0' })),
                state('visible', style({ opacity: '1' })),
                transition('hidden => visible', [
                    animate('200ms ease-in-out')
                ])
            ])
        ]
    })
], BaseFormComponent);
export { BaseFormComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1mb3JtLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3N0aW11bHNvZnQtdmlld2VyLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZm9ybXMvYmFzZS1mb3JtLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBVSxLQUFLLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQWMsTUFBTSxlQUFlLENBQUM7QUFDdEcsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBa0IsTUFBTSxxQkFBcUIsQ0FBQztBQUNqRyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUE2RTdDLElBQWEsaUJBQWlCLEdBQTlCLE1BQWEsaUJBQWlCO0lBc0I1QixZQUFtQixLQUFtQixFQUFTLE1BQXFCLEVBQVMsV0FBd0I7UUFBbEYsVUFBSyxHQUFMLEtBQUssQ0FBYztRQUFTLFdBQU0sR0FBTixNQUFNLENBQWU7UUFBUyxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQWxCM0YscUJBQWdCLEdBQXNCLElBQUksWUFBWSxFQUFFLENBQUM7UUFDekQsV0FBTSxHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO1FBRWhELFVBQUssR0FBRyxDQUFDLENBQUM7UUFTVixlQUFVLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLGdCQUFXLEdBQUcsSUFBSSxDQUFDO1FBQ25CLGtCQUFhLEdBQUcsSUFBSSxDQUFDO1FBRTlCLFlBQU8sR0FBRyxNQUFNLENBQUM7SUFFd0YsQ0FBQztJQUUxRyxRQUFRLEtBQUssQ0FBQztJQUVkLGNBQWMsQ0FBQyxLQUFxQjtRQUNsQyxJQUFJLEtBQUssQ0FBQyxPQUFPLEtBQUssU0FBUyxFQUFFO1lBQy9CLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2xCLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLEVBQUU7Z0JBQzNCLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDcEQ7U0FDRjtJQUNILENBQUM7SUFFRCxhQUFhLENBQUMsS0FBcUI7UUFDakMsSUFBSSxLQUFLLENBQUMsT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUM5QixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztTQUN2QjtRQUNELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzVDLENBQUM7Q0FDRixDQUFBOztZQW5CMkIsWUFBWTtZQUFpQixhQUFhO1lBQXNCLFdBQVc7O0FBcEIvRTtJQUFyQixTQUFTLENBQUMsU0FBUyxDQUFDO2tEQUFxQjtBQUVoQztJQUFULE1BQU0sRUFBRTsyREFBMEQ7QUFDekQ7SUFBVCxNQUFNLEVBQUU7aURBQWdEO0FBRWhEO0lBQVIsS0FBSyxFQUFFO2dEQUFXO0FBQ1Y7SUFBUixLQUFLLEVBQUU7a0RBQWlCO0FBQ2hCO0lBQVIsS0FBSyxFQUFFO2tEQUFpQjtBQUNoQjtJQUFSLEtBQUssRUFBRTtxREFBb0I7QUFDbkI7SUFBUixLQUFLLEVBQUU7Z0RBQWU7QUFDZDtJQUFSLEtBQUssRUFBRTttREFBa0I7QUFDakI7SUFBUixLQUFLLEVBQUU7MkRBQTBCO0FBQ3pCO0lBQVIsS0FBSyxFQUFFOytDQUFjO0FBQ2I7SUFBUixLQUFLLEVBQUU7cURBQW9CO0FBQ25CO0lBQVIsS0FBSyxFQUFFO3FEQUFtQjtBQUNsQjtJQUFSLEtBQUssRUFBRTtzREFBb0I7QUFDbkI7SUFBUixLQUFLLEVBQUU7d0RBQXNCO0FBbEJuQixpQkFBaUI7SUEzRTdCLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSxlQUFlO1FBQ3pCLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E4RFQ7UUFDRCxVQUFVLEVBQUU7WUFDVixPQUFPLENBQUMsVUFBVSxFQUFFO2dCQUNsQixLQUFLLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUN4QyxLQUFLLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUN6QyxVQUFVLENBQUMsbUJBQW1CLEVBQUU7b0JBQzlCLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQztpQkFBQyxDQUFDO2FBQ2pDLENBQUM7U0FDSDtLQUNGLENBQUM7R0FFVyxpQkFBaUIsQ0F5QzdCO1NBekNZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgRXZlbnRFbWl0dGVyLCBPdXRwdXQsIFZpZXdDaGlsZCwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBNb2RlbFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9tb2RlbC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSGVscGVyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2hlbHBlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgdHJpZ2dlciwgc3RhdGUsIHRyYW5zaXRpb24sIHN0eWxlLCBhbmltYXRlLCBBbmltYXRpb25FdmVudCB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5pbXBvcnQgeyBGb3JtU2VydmljZSB9IGZyb20gJy4vZm9ybS5zZXJ2aWNlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnc3RpLWJhc2UtZm9ybScsXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgIDxkaXYgI2VsZW1lbnQgY2xhc3M9XCJzdGlKc1ZpZXdlckZvcm1cIlxyXG4gICAgICBbc3R5bGUuekluZGV4XT1cImxldmVsICogMTAgKyAxXCJcclxuICAgICAgW0AuZGlzYWJsZWRdPVwiIW1vZGVsLm9wdGlvbnMudG9vbGJhci5tZW51QW5pbWF0aW9uXCJcclxuICAgICAgW3N0eWxlLmZvbnRGYW1pbHldPVwiZm9udEZhbWlseVwiXHJcbiAgICAgIFtzdHlsZS5jb2xvcl09XCJjb2xvclwiXHJcbiAgICAgIFtzdHlsZS5mb250U2l6ZV09XCJmb250U2l6ZVwiXHJcbiAgICAgIFtzdHlsZS5sZWZ0LnB4XT1cImZvcm1TZXJ2aWNlLmZvcm0/LmxlZnRcIlxyXG4gICAgICBbc3R5bGUudG9wLnB4XT1cImZvcm1TZXJ2aWNlLmZvcm0/LnRvcFwiXHJcbiAgICAgIFtzdHlsZS5kaXNwbGF5XT1cImRpc3BsYXlcIlxyXG4gICAgICBbQHNob3dGb3JtXT1cImZvcm1TZXJ2aWNlLmZvcm0/Lm5hbWUgPT0gbmFtZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nXCJcclxuICAgICAgKEBzaG93Rm9ybS5zdGFydCk9XCJzdGFydEFuaW1hdGlvbigkZXZlbnQpXCJcclxuICAgICAgKEBzaG93Rm9ybS5kb25lKT1cImRvbmVBbmltYXRpb24oJGV2ZW50KVwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwic3RpSnNWaWV3ZXJGb3JtSGVhZGVyXCJcclxuICAgICAgICAobW91c2Vkb3duKT1cImZvcm1TZXJ2aWNlLnN0YXJ0TW92ZShuYW1lLCAkZXZlbnQpXCJcclxuICAgICAgICAodG91Y2hzdGFydCk9XCJmb3JtU2VydmljZS5zdGFydE1vdmUobmFtZSwgbnVsbCwgJGV2ZW50KVwiXHJcbiAgICAgICAgKHRvdWNobW92ZSk9XCJmb3JtU2VydmljZS5tb3ZlKCRldmVudClcIlxyXG4gICAgICAgICh0b3VjaGVuZCk9XCJmb3JtU2VydmljZS5zdG9wTW92ZSgpXCI+XHJcbiAgICAgICAgPHRhYmxlIGNsYXNzPVwic3RpSnNWaWV3ZXJDbGVhckFsbFN0eWxlc1wiIGNlbGxwYWRkaW5nPVwiMFwiIGNlbGxzcGFjaW5nPVwiMFwiIHN0eWxlPVwid2lkdGg6IDEwMCU7XCI+XHJcbiAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgIDx0ciBjbGFzcz1cInN0aUpzVmlld2VyQ2xlYXJBbGxTdHlsZXNcIj5cclxuICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJzdGlKc1ZpZXdlckNsZWFyQWxsU3R5bGVzXCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiBsZWZ0OyBwYWRkaW5nOiA1cHggMTBweCA4cHggMTVweDtcIj5cclxuICAgICAgICAgICAgICAgIHt7Y2FwdGlvbn19XHJcbiAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJoZWxwVXJsICE9IG51bGwgJiYgbW9kZWwub3B0aW9ucy5hcHBlYXJhbmNlLnNob3dEaWFsb2dzSGVscFwiIGNsYXNzPVwic3RpSnNWaWV3ZXJDbGVhckFsbFN0eWxlc1wiIHN0eWxlPVwid2lkdGg6IDIwcHg7IHRleHQtYWxpZ246IHJpZ2h0OyBwYWRkaW5nOiAycHggMHB4IDFweCAwcHg7IHZlcnRpY2FsLWFsaWduOiB0b3A7XCI+XHJcbiAgICAgICAgICAgICAgICA8c3RpLWJ1dHRvbiBbaW1hZ2VNYXJnaW5dPVwiJzAgMnB4IDAgMnB4J1wiIFtkaXNwbGF5XT1cIidpbmxpbmUtYmxvY2snXCIgKGFjdGlvbik9XCJoZWxwZXIuc2hvd0hlbHBXaW5kb3coaGVscFVybClcIj5cclxuICAgICAgICAgICAgICAgIDwvc3RpLWJ1dHRvbj5cclxuICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgIDx0ZCBjbGFzcz1cInN0aUpzVmlld2VyQ2xlYXJBbGxTdHlsZXNcIiBzdHlsZT1cInZlcnRpY2FsLWFsaWduOiB0b3A7IHdpZHRoOiAzMHB4OyB0ZXh0LWFsaWduOiByaWdodDsgcGFkZGluZzogMnB4IDFweCAxcHg7XCI+XHJcbiAgICAgICAgICAgICAgICA8c3RpLWJ1dHRvbiBbaW1hZ2VNYXJnaW5dPVwiJzAgMnB4IDAgMnB4J1wiIFtkaXNwbGF5XT1cIidpbmxpbmUtYmxvY2snXCIgW2ltYWdlTmFtZV09XCInQ2xvc2VGb3JtLnBuZydcIiAoYWN0aW9uKT1cImZvcm1TZXJ2aWNlLmNsb3NlRm9ybShuYW1lKVwiPlxyXG4gICAgICAgICAgICAgICAgPC9zdGktYnV0dG9uPlxyXG4gICAgICAgICAgICAgIDwvdGQ+XHJcbiAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgIDwvdGFibGU+XHJcbiAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgPGRpdiBjbGFzcz1cInN0aUpzVmlld2VyRm9ybUNvbnRhaW5lclwiIFtzdHlsZS5wYWRkaW5nXT1cImNvbnRhaW5lclBhZGRpbmdcIj5cclxuICAgICAgICA8bmctY29udGVudD5cclxuICAgICAgICA8L25nLWNvbnRlbnQ+XHJcbiAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgPGRpdiAqbmdJZj1cInNob3dTZXBhcmF0b3JcIiBjbGFzcz1cInN0aUpzVmlld2VyRm9ybVNlcGFyYXRvclwiPjwvZGl2PlxyXG5cclxuICAgICAgPGRpdiAqbmdJZj1cInNob3dCdXR0b25zXCIgY2xhc3M9XCJzdGlKc1ZpZXdlckZvcm1CdXR0b25zUGFuZWxcIj5cclxuICAgICAgICA8dGFibGUgY2xhc3M9XCJzdGlKc1ZpZXdlckNsZWFyQWxsU3R5bGVzXCIgY2VsbHBhZGRpbmc9XCIwXCIgY2VsbHNwYWNpbmc9XCIwXCI+XHJcbiAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgIDx0ciBjbGFzcz1cInN0aUpzVmlld2VyQ2xlYXJBbGxTdHlsZXNcIj5cclxuICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJzdGlKc1ZpZXdlckNsZWFyQWxsU3R5bGVzXCIgc3R5bGU9XCJwYWRkaW5nOiA4cHg7XCI+XHJcbiAgICAgICAgICAgICAgICA8c3RpLWZvcm0tYnV0dG9uIFtjYXB0aW9uXT1cIm1vZGVsLmxvYygnQnV0dG9uT2snKVwiIChhY3Rpb24pPVwiYWN0aW9uLmVtaXQoKVwiPlxyXG4gICAgICAgICAgICAgICAgPC9zdGktZm9ybS1idXR0b24+XHJcbiAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJzaG93Q2FuY2VsXCIgY2xhc3M9XCJzdGlKc1ZpZXdlckNsZWFyQWxsU3R5bGVzXCIgc3R5bGU9XCJwYWRkaW5nOiA4cHggOHB4IDhweCAwcHg7XCI+XHJcbiAgICAgICAgICAgICAgICA8c3RpLWZvcm0tYnV0dG9uIFtjYXB0aW9uXT1cIm1vZGVsLmxvYygnQnV0dG9uQ2FuY2VsJylcIiAoYWN0aW9uKT1cImZvcm1TZXJ2aWNlLmNsb3NlRm9ybShuYW1lKVwiPlxyXG4gICAgICAgICAgICAgICAgPC9zdGktZm9ybS1idXR0b24+XHJcbiAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgPC90YWJsZT5cclxuICAgICAgPC9kaXY+XHJcblxyXG4gICAgPC9kaXY+XHJcbiAgYCxcclxuICBhbmltYXRpb25zOiBbXHJcbiAgICB0cmlnZ2VyKCdzaG93Rm9ybScsIFtcclxuICAgICAgc3RhdGUoJ2hpZGRlbicsIHN0eWxlKHsgb3BhY2l0eTogJzAnIH0pKSxcclxuICAgICAgc3RhdGUoJ3Zpc2libGUnLCBzdHlsZSh7IG9wYWNpdHk6ICcxJyB9KSksXHJcbiAgICAgIHRyYW5zaXRpb24oJ2hpZGRlbiA9PiB2aXNpYmxlJywgW1xyXG4gICAgICAgIGFuaW1hdGUoJzIwMG1zIGVhc2UtaW4tb3V0JyldKVxyXG4gICAgXSlcclxuICBdXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgQmFzZUZvcm1Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xyXG5cclxuICBAVmlld0NoaWxkKCdlbGVtZW50JykgZWxlbWVudDogRWxlbWVudFJlZjtcclxuXHJcbiAgQE91dHB1dCgpIGNoYW5nZVZpc2liaWxpdHk6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gIEBPdXRwdXQoKSBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICBASW5wdXQoKSBsZXZlbCA9IDE7XHJcbiAgQElucHV0KCkgY2FwdGlvbjogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIGhlbHBVcmw6IHN0cmluZztcclxuICBASW5wdXQoKSBmb250RmFtaWx5OiBzdHJpbmc7XHJcbiAgQElucHV0KCkgY29sb3I6IHN0cmluZztcclxuICBASW5wdXQoKSBmb250U2l6ZTogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIGNvbnRhaW5lclBhZGRpbmc6IHN0cmluZztcclxuICBASW5wdXQoKSBuYW1lOiBzdHJpbmc7XHJcbiAgQElucHV0KCkgZGVmYXVsdFRvcDogbnVtYmVyO1xyXG4gIEBJbnB1dCgpIHNob3dDYW5jZWwgPSB0cnVlO1xyXG4gIEBJbnB1dCgpIHNob3dCdXR0b25zID0gdHJ1ZTtcclxuICBASW5wdXQoKSBzaG93U2VwYXJhdG9yID0gdHJ1ZTtcclxuXHJcbiAgZGlzcGxheSA9ICdub25lJztcclxuXHJcbiAgY29uc3RydWN0b3IocHVibGljIG1vZGVsOiBNb2RlbFNlcnZpY2UsIHB1YmxpYyBoZWxwZXI6IEhlbHBlclNlcnZpY2UsIHB1YmxpYyBmb3JtU2VydmljZTogRm9ybVNlcnZpY2UpIHsgfVxyXG5cclxuICBuZ09uSW5pdCgpIHsgfVxyXG5cclxuICBzdGFydEFuaW1hdGlvbihldmVudDogQW5pbWF0aW9uRXZlbnQpIHtcclxuICAgIGlmIChldmVudC50b1N0YXRlID09PSAndmlzaWJsZScpIHtcclxuICAgICAgdGhpcy5kaXNwbGF5ID0gJyc7XHJcbiAgICAgIGlmICh0aGlzLmRlZmF1bHRUb3AgIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuZm9ybVNlcnZpY2UuY2VudGVyRm9ybSh0aGlzLCB0aGlzLmRlZmF1bHRUb3ApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkb25lQW5pbWF0aW9uKGV2ZW50OiBBbmltYXRpb25FdmVudCkge1xyXG4gICAgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICdoaWRkZW4nKSB7XHJcbiAgICAgIHRoaXMuZGlzcGxheSA9ICdub25lJztcclxuICAgIH1cclxuICAgIHRoaXMuY2hhbmdlVmlzaWJpbGl0eS5lbWl0KGV2ZW50LnRvU3RhdGUpO1xyXG4gIH1cclxufVxyXG4iXX0=